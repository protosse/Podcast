//
//  AnyPublisher+HandyJSON.swift
//  Podcast
//
//  Created by liuliu on 2021/5/28.
//

#if canImport(Combine)

import Foundation
import Combine
import Moya
import HandyJSON

/// Extension for processing raw NSData generated by network access.
@available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
public extension AnyPublisher where Output == Response, Failure == MoyaError {
    /// Maps received data at key path into a Decodable object. If the conversion fails, the signal errors.
    func map<D: HandyJSON>(_ type: D.Type, atKeyPath keyPath: String? = nil) -> AnyPublisher<D, MoyaError> {
        return unwrapThrowable { response in
            let str = try response.mapString()
            log.debug("Request: \(response.request?.httpMethod ?? "") \(response.request?.url?.absoluteString ?? "")")
            log.debug(str)
            guard let m = D.deserialize(from: str, designatedPath: keyPath) else {
                throw MoyaError.jsonMapping(response)
            }
            return m
        }
    }
    
    func map<D: HandyJSON>(_ type: [D].Type, atKeyPath keyPath: String? = nil) -> AnyPublisher<[D], MoyaError> {
        return unwrapThrowable { response in
            let str = try response.mapString()
            log.debug("Request: \(response.request?.httpMethod ?? "") \(response.request?.url?.absoluteString ?? "")")
            log.debug(str)
            guard let m = [D].deserialize(from: str, designatedPath: keyPath) else {
                throw MoyaError.jsonMapping(response)
            }
            return m.compactMap{ $0 }
        }
    }
}

@available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension AnyPublisher where Failure == MoyaError {

    // Workaround for a lot of things, actually. We don't have Publishers.Once, flatMap
    // that can throw and a lot more. So this monster was created because of that. Sorry.
    private func unwrapThrowable<T>(throwable: @escaping (Output) throws -> T) -> AnyPublisher<T, MoyaError> {
        self.tryMap { element in
            try throwable(element)
        }
        .mapError { error -> MoyaError in
            if let moyaError = error as? MoyaError {
                return moyaError
            } else {
                return .underlying(error, nil)
            }
        }
        .eraseToAnyPublisher()
    }
}

#endif

